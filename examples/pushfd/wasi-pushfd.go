package main

import (
	"context"
	_ "embed"
	"fmt"
	"log"
	"net"
	"os"
	"sync"

	"github.com/tetratelabs/wazero"
	"github.com/tetratelabs/wazero/api"
	"github.com/tetratelabs/wazero/imports/wasi_snapshot_preview1"
)

// writefdWasm was generated by the following:
//
//	cd testdata; wat2wasm --debug-names wasi_fd_write.wat
//
//go:embed testdata/wasi_fd_write.wasm
var writefdWasm []byte

func main() {
	// Choose the context to use for function calls.
	ctx := context.Background()

	// Prepare a cache directory.
	cacheDir, err := os.MkdirTemp("", "example")
	if err != nil {
		log.Panicln(err)
	}
	defer os.RemoveAll(cacheDir)

	// Initializes the new compilation cache with the cache directory.
	// This allows the compilation caches to be shared even across multiple OS processes.
	cache, err := wazero.NewCompilationCacheWithDir(cacheDir)
	if err != nil {
		log.Panicln(err)
	}
	defer cache.Close(ctx)

	// Creates a shared runtime config to share the cache across multiple wazero.Runtime.
	runtimeConfig := wazero.NewRuntimeConfig().WithCompilationCache(cache)

	// Create a new WebAssembly Runtime.
	r := wazero.NewRuntimeWithConfig(ctx, runtimeConfig)
	defer r.Close(ctx) // This closes everything this Runtime created.

	wasi_snapshot_preview1.MustInstantiate(ctx, r)

	mConfig := wazero.NewModuleConfig()
	mConfig.WithStdout(os.Stdout)

	m, err := r.Instantiate(ctx, writefdWasm)
	if err != nil {
		log.Panicf("failed to instantiate: %v", err)
	}

	pushTCPConn(ctx, m)
	pushOSFile(ctx, m)
}

func pushOSFile(ctx context.Context, m api.Module) {
	if m == nil {
		log.Panicln("m is nil")
	}

	// create a file pair
	f, err := os.CreateTemp("", "example")
	if err != nil {
		log.Panicf("failed to create temp file: %v", err)
	}
	defer os.Remove(f.Name())

	fd, ok := m.InsertOSFile(f)
	if !ok {
		log.Panicln("failed to insert file")
	}

	results, err := m.ExportedFunction("_write").Call(ctx, uint64(fd))
	if err != nil {
		log.Panicf("failed to call _write: %v", err)
	}
	// check the result
	if len(results) != 1 {
		log.Panicf("unexpected result length: %d", len(results))
	}
	result := results[0]
	if resi32 := api.DecodeI32(result); resi32 != 12 {
		log.Panicf("unexpected result: %d", resi32)
	}

	// reopen the file, since the original copy is pushed into the WebAssembly module
	f, err = os.Open(f.Name())
	if err != nil {
		log.Panicf("failed to open temp file: %v", err)
	}

	// read the result
	buf := make([]byte, 1024)
	n, err := f.Read(buf)
	if err != nil {
		log.Panicf("failed to read: %v", err)
	}

	fmt.Printf("read %d bytes: %s", n, string(buf[:n]))
}

func pushTCPConn(ctx context.Context, m api.Module) {
	if m == nil {
		log.Panicln("m is nil")
	}

	// create a TCP Conn pair
	lis, err := net.ListenTCP("tcp", nil)
	if err != nil {
		log.Panicf("failed to listen: %v", err)
	}
	defer lis.Close()

	var lisConn *net.TCPConn
	var lisWg sync.WaitGroup
	lisWg.Add(1)
	go func() {
		var err error
		defer lisWg.Done()
		lisConn, err = lis.AcceptTCP()
		if err != nil {
			log.Panicf("failed to accept: %v", err)
		}
	}()

	dialConn, err := net.DialTCP("tcp", nil, lis.Addr().(*net.TCPAddr))
	if err != nil {
		log.Panicf("failed to dial: %v", err)
	}

	lisWg.Wait()

	fd, ok := m.InsertTCPConn(lisConn)
	if !ok {
		log.Panicln("failed to insert TCPConn")
	}

	results, err := m.ExportedFunction("_write").Call(ctx, uint64(fd))
	if err != nil {
		log.Panicf("failed to call _write: %v", err)
	}
	// check the result
	if len(results) != 1 {
		log.Panicf("unexpected result length: %d", len(results))
	}
	result := results[0]
	if resi32 := api.DecodeI32(result); resi32 != 12 {
		log.Panicf("unexpected result: %d", resi32)
	}

	// read the result
	buf := make([]byte, 1024)
	n, err := dialConn.Read(buf)
	if err != nil {
		log.Panicf("failed to read: %v", err)
	}

	fmt.Printf("read %d bytes: %s", n, string(buf[:n]))
}
